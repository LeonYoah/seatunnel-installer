# SeaTunnel Installer → 运维控制台：路线图与迭代规划

本项目当前定位是 **SeaTunnel Zeta 一键安装（含 Web 引导）**。后续演进目标是：在保留安装器能力的同时，扩展为 **“任务 + 运维 + 可观测 + 扩缩容”的控制面**（Control Plane），覆盖裸机 / 容器 / K8s 三种部署形态，并支持多租户与多数据库。

> 本文档只做路径规划，不落实现代码；每个迭代描述“要做什么/不做什么/验收标准”。

---

## 1. 目标与边界

### 1.1 产品目标（要实现）
- **多租户**：Tenant/Workspace 隔离，RBAC、审计日志。
- **任务全生命周期**：提交、运行、停止、重试、回滚、版本化配置、日志/事件查看。
- **集群运维**：节点管理、发布/重启、健康检查、扩缩容（手动→策略）。
- **可观测与告警**：指标/日志/事件，预置 dashboard，告警规则与通知渠道。
- **排障诊断**：一键收集诊断包、故障指纹库、建议与可选的一键修复。
- **部署形态**：裸机（systemd）、容器（docker/compose）、K8s（Helm）。
- **数据库支持**：SQLite（单机/PoC）、MySQL、PostgreSQL、Oracle。

### 1.2 非目标（暂不做/谨慎做）
- 自研大而全调度平台（可先做轻量调度与外部对接）。
- 自研完整可观测栈（优先对接 Prometheus/Grafana/Loki/ELK）。
- 未经授权的远程任意命令执行（运维动作必须“白名单化/参数化/可审计”）。

---

## 2. 推荐演进架构（从 Shell 平滑升级）

### 2.1 分层
- **Installer（Go，主路径）**
  - 负责 install/uninstall/upgrade/rollback/diagnose：依赖检查、生成配置、生成 systemd/compose/helm 产物、落审计所需的机器信息采集等。
  - 可选保留极薄 `bootstrap.sh`：用于“下载/解压/拉起 Go 二进制（或容器/helm）”的胶水，不承载业务逻辑。
- **Control Plane（服务化，建议 Go）**
  - Web UI + API：租户/RBAC/审计、任务/集群/节点资源模型、长流程编排、策略、事件流。
- **Agent（节点侧，Go）**
  - 心跳与健康检查、指标/日志采集、执行“受控动作”（重启/拉起/收集诊断包/扩缩容脚本）。

### 2.2 关键原则
- **控制面不直接 SSH 执行任意命令**：统一通过 Agent 执行“动作模板（action）+ 参数”，并写审计。
- **所有资源强制租户域（tenant_id）**：避免数据越权。
- **长耗时操作异步化**：进入队列（DB 持久化），前端通过事件流查看进度。
- **数据库方言最小化**：避免强依赖 JSON 类型/特性索引；配置与事件 payload 使用 TEXT/CLOB。

---

## 3. 资源模型（最低可用集合）

- Tenant：租户
- Workspace：租户下的隔离空间（可对应项目/业务线）
- Cluster：一个 SeaTunnel 集群（裸机/容器/K8s）
- Node：节点/Pod（包含 role、状态、心跳、版本）
- Task：任务定义（模板、参数、版本、标签）
- Run：一次任务运行（状态机、开始/结束、错误原因）
- Artifact：任务包/connector 包/诊断包
- Alert：告警（事件源、级别、对象、静默/恢复）
- Secret：凭证（加密存储、访问受控）
- AuditLog：审计日志（谁在何时对什么做了什么）

---

## 4. 迭代规划（建议）

> 迭代编号仅用于规划；时间可按团队节奏调整（每迭代 1–3 周）。

### Iteration 0（已具备/进行中）：安装器 + 控制台原型
**交付**
- 一键安装（Shell）与 Web 安装向导稳定。
- 运维控制台原型页面（静态页面/假数据）用于对齐信息架构与交互。
  - 说明：Shell 安装器作为当前基线（baseline），后续迭代以 Go Installer/Control Plane/Agent 为主路径。

**不做**
- 不引入真实任务/集群 API（只做原型）。

**验收**
- UI 原型可访问、导航完整、页面布局一致。

---

### Iteration 1：控制面骨架（单实例可运行）
**目标**
- 让“控制面”成为一个可启动的服务（先单实例），把 UI 的“数据模式”从假数据切到 API。

**交付**
- Go Installer 最小骨架：提供 `install/uninstall/diagnose` 命令与配置生成（可先不接真实执行，但接口与参数先定型）。
- API 规范（OpenAPI/Markdown 均可）与统一错误码。
- 基础认证（本地用户/Token）、审计日志最小闭环。
- 数据库存储层：**SQLite**（默认），抽象出可扩展到 MySQL/PG/Oracle 的接口。
- 控制台页面数据接入：Dashboard/Tasks/Clusters/Diagnostics/Plugins/Settings 至少返回结构化 JSON（可先 mock 到 DB）。

**不做**
- 不做完整 RBAC（先单租户/单 workspace）。
- 不做真实任务执行（先记录与展示状态机）。

**验收**
- 启动后 UI 可看到来自 API 的数据（非硬编码）。
- 任意写操作产生审计记录。

---

### Iteration 2：多租户 + RBAC + 审计完善
**目标**
- 把“租户隔离”做成强约束，形成企业可用安全底座。

**交付**
- Tenant/Workspace 管理：创建、禁用、配额（可选）。
- RBAC：角色/权限点（resource/action）模型；最小内置角色（Owner/Admin/Viewer）。
- 认证增强：JWT + 刷新策略；可选 OIDC/LDAP 预留接口。
- Secret 管理：加密存储（至少支持 AES-GCM + KMS 预留），访问受控并审计。

**不做**
- 不做复杂计费/账单。

**验收**
- 不同租户数据完全隔离（API 强制 tenant_id）。
- 所有敏感操作可追溯（审计可检索/导出）。

---

### Iteration 3：数据库矩阵（MySQL/PG/Oracle）
**目标**
- 控制面在企业常见数据库上可运行与可迁移。

**交付**
- 存储适配：MySQL、PostgreSQL、Oracle（与 SQLite 一致的数据模型能力）。
- 迁移体系：按方言维护 migrations（sqlite/mysql/pg/oracle）。
- 文档：连接串、初始化、迁移与备份恢复。

**不做**
- 不做跨库双写/在线迁移（先导入导出级别）。

**验收**
- 同一套功能在四种 DB 上启动通过，核心用例（租户/任务/集群）可用。

---

### Iteration 4：任务模型与运行闭环（先“编排”，再“执行”）
**目标**
- 用户能在控制台里创建/版本化任务，并形成运行记录与日志入口。

**交付**
- 任务定义：模板、YAML/表单双模式、版本化、Diff/回滚。
- 运行状态机：Pending/Running/Succeeded/Failed/Stopped/Paused（最小集合）。
- 日志与事件：Run 级别日志流入口（可先接已有日志文件/占位接口）。
- 与安装器衔接：复用安装生成的集群信息（Cluster 资源注册）。

**不做**
- 不做复杂 DAG 调度（先 cron/手动触发）。

**验收**
- 任务从创建→提交→生成 Run→状态流转→可查看日志/事件（哪怕执行先是模拟/占位）。

---

### Iteration 5：Agent 与“受控运维动作”
**目标**
- 引入 Agent 承担节点侧能力，避免控制面直接执行命令。

**交付**
- Agent：心跳、节点信息上报、健康检查；动作执行框架（action registry）。
- 运维动作（白名单化）：重启服务、拉起 worker、收集诊断包、查看版本/配置快照。
- 权限与审计：每次 action 都记录“谁/对谁/做了什么/结果/耗时”。

**不做**
- 不做自动自愈策略（先手动触发）。

**验收**
- 控制台可对节点触发动作并看到进度与结果；异常可追溯。

---

### Iteration 6：可观测与告警（对接生态）
**目标**
- 给运维“看得见”和“能告警”的能力。

**交付**
- 指标：定义 SeaTunnel/Task/Node 核心指标规范（命名、label）。
- 对接：Prometheus + Grafana（仪表盘 JSON）、Alertmanager（规则模板）。
- 日志：对接 Loki/ELK（二选一先落地），任务/节点日志可检索。
- 告警：告警列表、静默、通知渠道（钉钉/企微/邮件至少一种）。

**验收**
- 预置 dashboard 可直接导入；告警触发后可在控制台看到并通知。

---

### Iteration 7：扩缩容与发布（裸机/容器/K8s 全覆盖）
**目标**
- 把“扩容/升级/发布”做成流程化能力，三种部署形态都可用。

**交付**
- 裸机：systemd 单元的滚动重启/升级流程（含回滚点）。
- 容器：compose 编排（含升级/回滚策略）。
- K8s：Helm chart（或 Kustomize），支持滚动升级、水平扩缩。
- 扩缩容：手动扩缩 → 基于阈值策略（CPU/队列长度/延迟）自动扩缩（可后置）。

**验收**
- 三种形态至少完成“扩容一次 + 滚动升级一次 + 可回滚”闭环。

---

## 5. 建议的文档产物清单
- `docs/ROADMAP.md`：路线图（本文件）
- `docs/ARCHITECTURE.md`：组件图、部署图、数据流、安全边界
- `docs/API.md`：OpenAPI/接口约定、错误码、鉴权方式
- `docs/DB.md`：四种数据库部署与迁移说明
- `docs/DEPLOYMENT.md`：裸机/容器/K8s 的安装与升级策略

---

## 6. Shell → Go：退场策略（什么时候合理移除）

> 目标是“全面 Go 化”，但**建议保留极薄的 bootstrap**（下载/解压/拉起 control-plane/agent），避免因为权限/环境差异导致安装不可用。下面定义“可移除”的边界与触发条件。

### 6.1 推荐的迁移阶段

**阶段 A（Go 主路径）**：从第一个可用版本开始就“全面 Go 化”  
- Go Installer + Go Control Plane + Go Agent 同步推进：安装/卸载/诊断/升级/回滚与运维动作全部走 Go/Agent，不依赖 CGI 执行 Shell 逻辑。
- Shell 脚本仅作为：
  - `bootstrap.sh`（可选）：下载/解压/拉起二进制或容器/Helm 的最小胶水；
  - `legacy`（可选）：为存量用户保留 1–2 个大版本的兼容入口（不新增功能）。
- 目的：从 Day1 统一“安全边界/审计/幂等/状态机/多租户”，避免后续迁移成本指数上升。

**阶段 B（兼容期）**：对旧 Shell 模式做“只读/只修”  
- 明确兼容边界：仅修复安全与关键 bug；不再扩展步骤与功能。
- 为用户提供迁移指南：配置迁移、数据迁移、命令替换与回滚路径。

**阶段 C（冻结期）**：Shell 功能冻结 + 标记弃用（deprecate）  
- Shell 只接收安全修复与兼容修补，不再新增功能。
- 文档与 UI 明确：推荐使用 Go Control Plane/Agent；Shell 仅作为 legacy 模式。

**阶段 D（移除期）**：Shell 从主发行版移除（或拆分到 legacy 分支/仓库）  
- 主分支只保留 `bootstrap.sh`（可选）与部署产物（systemd/compose/helm），核心逻辑全部 Go。

### 6.2 “可以移除 Shell”的硬性门槛（建议全部满足）
- **功能对齐（Parity）**：安装/卸载/升级/回滚/诊断/扩缩容这几类关键路径，Go/Agent 均有等价实现，并且在三种形态（裸机/容器/K8s）至少各跑通一次。
- **幂等与可恢复**：任何长流程中断后可重入（retry/resume），不会把集群落在“半配置”状态。
- **安全可审计**：所有运维动作必须白名单化、参数化、可授权（RBAC）并落审计；不依赖 CGI 执行任意命令。
- **数据库矩阵通过**：SQLite/MySQL/PG/Oracle 至少核心流程通过（创建租户/注册集群/创建任务/触发运行/查看事件）。
- **发布可控**：支持滚动升级（控制面/agent）、向后兼容 1 个版本的 API/数据迁移。
- **自动化验证**：具备最少的 e2e 检查（启动→注册→执行→诊断→回滚）脚本或流水线，能防止回归。

### 6.3 推荐的弃用节奏（语义化版本）
- 在 `vX.Y`：在 README/UI/CLI 输出中标记 Shell 为 **Deprecated**，并给出迁移指南与替代命令。
- 在 `v(X+1).0`：默认走 Go 路径（Shell 仍可用，但需要显式 `--legacy` 或单独下载 legacy 包）。
- 在 `v(X+2).0`：从主发行包移除 Shell（或迁移到 `legacy/` 目录与维护分支），只保留 bootstrap。

### 6.4 现实建议：哪些 Shell 可能“永远不必 0”
- **极薄 bootstrap**：负责在没有运行时/依赖的情况下拉起 Go 二进制（或容器/helm）；这个脚本可以非常短、非常稳定。
- **平台适配胶水**：例如 root 权限准备（创建用户/目录、写 systemd），可做成 Go 的子命令，但某些发行版差异保留脚本也合理。
